import dataclasses
from math import log
from collections import deque
from dataclasses import dataclass
from typing import Optional, List, Dict, Set
from flask import current_app
from flask_bcrypt import Bcrypt
import re

import model.tagDao
import model.notificationDao
from utils.mongo_store_broker import mongo
from bson.objectid import ObjectId


@dataclass  # Autogenerated __init__, __eq___ and __repr__ from given fields
class User:
    friends: list
    name: str
    privacy_control: int
    username: str
    password: str
    tags: List[Dict[str, int]]
    seen: Set[ObjectId]
    photo_url: Optional[str] = "https://cdn.pixabay.com/photo/2015/10/05/22/37/blank-profile-picture-973460_1280.png"
    _id: Optional[ObjectId] = dataclasses.field(default_factory=ObjectId)

    def __post_init__(self):
        self.seen = set(self.seen)

    @property
    def id(self):
        return self._id

    @property
    def notifications(self):
        return model.notificationDao.find_by_user_id(self._id)

    @property
    def chat_notifications(self):
        return model.notificationDao.find_by_user_id_type(self._id, "chat")

    @property
    def fr_notifications(self):
        return model.notificationDao.find_by_user_id_type(self._id, "friend_request")

    @property
    def tags_built(self):
        tags = []
        for tag in self.tags:
            t = dict()
            t["tag"] = model.tagDao.find_one(tag['tag_id'])
            t["affinity"] = tag['affinity']
            tags.append(t)
        return tags

    def __iter__(self):  # This method allows us to add support for dict() on an object
        for field in dataclasses.fields(self):
            yield field.name, getattr(self, field.name)

    def get_friends_dict(self):
        friends_dict = dict()
        for f in self.friends:
            friends_dict[f['friend_id']] = f['affinity']
        return friends_dict

    def bfs_get_visible_user_ids(self):
        """
        Gets all the visible user ids of this user given its privacy setting
        :return:
        """
        current_lvl = deque()  # Current level
        current_lvl.append(self.id)
        next_lvl = deque()  # Next level
        visited = [self.id]  # Visited nodes/users
        distance = 1  # Distance from start level

        while len(current_lvl) != 0:
            while len(current_lvl) != 0:
                current = current_lvl.popleft()
                neighbours = find_one(current).get_friends_dict().keys()

                for n in neighbours:
                    # Filtering criteria
                    # If node within reach of your privacy control
                    distance_within_privacy = distance <= self.privacy_control
                    # If other node has a higher privacy than distance
                    ns_privacy_control = distance <= find_one(n).privacy_control

                    # Visit node
                    if n not in visited and distance_within_privacy and ns_privacy_control:
                        next_lvl.append(n)
                        visited.append(n)

            distance += 1
            current_lvl = next_lvl
            next_lvl = deque()

        if self.privacy_control >= 6:  # since 6 means anyone can see, shows detached users
            users = get_all()
            freeusers = [user.id for user in users if (user.privacy_control >= 6)]
            for user in freeusers:
                if user not in visited:
                    visited.append(user)
        return visited

    def get_user_tags_ordered_by_affinity(self):
        tags = self.tags_built
        tags.sort(key=lambda x: x.get("affinity"))
        return tags

    def leave_tag(self, _id):
        for t in self.tags:
            if t["tag_id"] == ObjectId(_id):
                t["affinity"] = -5
                update_one(self.id, self)

    def joint_tag(self, tag_id):
        t = dict()
        if tag_id not in [u_tag["tag_id"] for u_tag in self.tags]:
            t["tag_id"] = ObjectId(tag_id)
            t["affinity"] = 1
            self.tags.append(t)
        else:
            for t in self.tags:
                if t["tag_id"] == ObjectId(tag_id):
                    t["affinity"] = 1

        update_one(self.id, self)

    def see_message(self, _id):
        print(type(self.seen))
        self.seen.add(_id)
        update_one(self.id, self)
        return self

    def add_friend(self, friend_id):
        if isinstance(friend_id, str):
            friend_id = ObjectId(friend_id)
        self.friends.append({"friend_id": friend_id, "affinity": 0})
        update_one(self.id, self)
        return self

    def delete_friend(self, friend_id):
        if isinstance(friend_id, str):
            friend_id = ObjectId(friend_id)
        for friend in self.friends:
            if friend["friend_id"] == friend_id:
                friend_id = friend
        if friend_id in self.friends:
            self.friends.remove(friend_id)
        print(self.friends)
        update_one(self.id, self)
        return self

    def remove_friend(self, friend_id):
        if isinstance(friend_id, str):
            friend_id = ObjectId(friend_id)
        self.friends = [f for f in self.friends if f["friend_id"] != friend_id]
        update_one(self.id, self)
        return self

    def set_name(self, name):
        self.name = name
        update_one(self.id, self)
        return self

    def set_username(self, username):
        self.username = username
        update_one(self.id, self)
        return self

    def set_password(self, password):
        self.password = password
        update_one(self.id, self)
        return self

    def set_photo_url(self, photo_url):
        self.photo_url = photo_url
        update_one(self.id, self)
        return self

    def set_privacy_control(self, privacy_control):
        self.privacy_control = privacy_control
        update_one(self.id, self)
        return self

    def get_common_friends(self, other_id):
        my_friends = set()
        their_friends = set()

        for f_af in self.friends:
            my_friends.add(f_af["friend_id"])

        other = find_one(other_id)
        for other_f_af in other.friends:
            their_friends.add(other_f_af["friend_id"])

        return my_friends.intersection(their_friends)

    def compare_affinity(self, other_id):
        self_affinity = dict()
        other_affinity = dict()

        for t in self.tags_built:
            self_affinity[t["tag"].name] = t["affinity"]

        other = find_one(other_id)
        for t in other.tags_built:
            other_affinity[t["tag"].name] = t["affinity"]

        def compare_vals(dict1, dict2, k):
            val1, val2 = None, None
            if k in dict1.keys():
                val1 = dict1[k]
            if k in dict2.keys():
                val2 = dict2[k]

            if val1 is not None and val2 is not None:
                return abs(max(val1, val2) - min(val1, val2))
            elif val1 is not None:
                return abs(val1)
            elif val2 is not None:
                return abs(val2)

        comp_affinity = {k: compare_vals(self_affinity, other_affinity, k) for k in self_affinity.keys()}
        for k in other_affinity.keys():
            comp_affinity[k] = compare_vals(self_affinity, other_affinity, k)
        return sum(v for v in comp_affinity.values())

    def change_tag_affinity(self, list_tag_ids, amount):
        for tag_id in list_tag_ids:
            tag = next(filter(lambda x: x["tag_id"] == tag_id, self.tags))
            if tag is not None:
                for t in self.tags:
                    if t["tag_id"] == tag["tag_id"]:
                        t["affinity"] += amount
                        if t["affinity"] < 0:
                            t["affinity"] = 0

            if tag is None:
                db_tag = model.tagDao.find_one(tag_id)
                if db_tag is not None:
                    self.tags.append({"tag_id": db_tag.id, "affinity": amount})

        update_one(self.id, self)
        return self


def find_one(_id: str | ObjectId):
    """
    Returns a user object from db
    :param _id:
    :return:
    """
    if isinstance(_id, str):
        _id = ObjectId(_id)
    res = mongo.db.users.find_one({"_id": _id})
    if res:
        return User(**res)


def find_user_by_username(username: str):
    res = mongo.db.users.find_one({"username": username})
    if res:
        return User(**res)


def find_user_by_id(_id: str | ObjectId):
    if isinstance(_id, str):
        _id = ObjectId(_id)
    res = mongo.db.users.find_one({"_id": _id})
    if res:
        return User(**res)


def find__positive_affinity_user_by_tag_id(_id: str | ObjectId):
    if isinstance(_id, str):
        _id = ObjectId(_id)
    res = mongo.db.users.find(
        {"tags": {"$elemMatch": {"tag_id": _id, "affinity": {"$gt": 0}}}}
    )
    return [User(**r) for r in res]


def insert_one(obj: dict | User):
    """
    Inserts one user object into the db
    :param obj:
    :return:
    """
    return mongo.db.users.insert_one(dict(obj)).inserted_id


def update_one(_id: str | ObjectId, obj: User):
    """
    Updates a user object inside the db
    :param _id:
    :param obj:
    :return:
    """
    new_obj = {k: v for (k, v) in zip(dict(obj).keys(), dict(obj).values())}

    if isinstance(_id, str):
        _id = ObjectId(_id)

    if isinstance(new_obj["seen"], set):
        new_obj["seen"] = list(new_obj["seen"])

    return mongo.db.users.update_one({"_id": _id},
                                     {"$set": dict(new_obj)})


def delete_one(_id: str | ObjectId):
    """
    Deletes a user object inside the db
    :param _id:
    :return:
    """
    if isinstance(_id, str):
        _id = ObjectId(_id)
    return mongo.db.users.delete_one({"_id": _id})


def get_all():
    """
    :return: - A list of user objects
    """
    res = mongo.db.users.find({})
    return [User(**r) for r in res]


def get_user_like_name(pattern: str):
    """
        :return: - A list of user objects with names or usernames matching the pattern
    """
    regx = re.compile(".*" + pattern + ".*", re.IGNORECASE)
    search = {
        "$or": [
            {"username": regx},
            {"name": regx},
        ]
    }
    res = mongo.db.users.find(search)
    return [User(**r) for r in res]


def login(username, psw) -> User:
    bcrypt: Bcrypt = current_app.bcrypt

    user = find_user_by_username(username)

    if user:
        if bcrypt.check_password_hash(user.password, psw):
            return user
